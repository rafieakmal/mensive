{"version":3,"sources":["webpack://GlitchedWriter/webpack/universalModuleDefinition","webpack://GlitchedWriter/webpack/bootstrap","webpack://GlitchedWriter/webpack/runtime/define property getters","webpack://GlitchedWriter/webpack/runtime/hasOwnProperty shorthand","webpack://GlitchedWriter/webpack/runtime/make namespace object","webpack://GlitchedWriter/./lib/esm/utils.js","webpack://GlitchedWriter/./lib/esm/presets.js","webpack://GlitchedWriter/./lib/esm/modules/options.js","webpack://GlitchedWriter/./lib/esm/modules/state.js","webpack://GlitchedWriter/./lib/esm/modules/emiter.js","webpack://GlitchedWriter/./lib/esm/modules/char.js","webpack://GlitchedWriter/./lib/esm/functions/setupCharTable.js","webpack://GlitchedWriter/./lib/esm/functions/letterize.js","webpack://GlitchedWriter/./lib/esm/functions/playlist/words.js","webpack://GlitchedWriter/./lib/esm/functions/playlist/letters.js","webpack://GlitchedWriter/./lib/esm/modules/animator.js","webpack://GlitchedWriter/./lib/esm/modules/queue.js","webpack://GlitchedWriter/./lib/esm/index.js"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","random","min","max","math","result","Math","floor","round","ceil","deleteRandom","array","splice","length","wait","time","Promise","resolve","setTimeout","promiseWhile","conditionFunc","actionPromise","whilst","then","arrayOfTheSame","Array","fill","animateWithClass","element","className","classList","remove","offsetWidth","add","getRandomFromRange","range","undefined","coinFlip","p","letterToLetterItem","string","stringToLetterItems","map","findHTMLPattern","wordsRgx","filterHtml","reg","RegExp","replace","glyphs","nier","full","letterlike","numbers","zalgo","neo","uppercase","presets","default","steps","interval","delay","changeChance","ghostChance","maxGhosts","oneAtATime","glyphsFromText","fillSpace","mode","html","letterize","endless","fps","typewriter","terminal","encrypted","bitbybit","cosmic","Options","writer","options","this","set","assign","parseOptions","updateInternal","_a","input","join","from","parseCharset","setCharset","space","Number","isInteger","iterable","isString","Set","forEach","x","push","filterDuplicates","previousString","goalText","charset","filter","l","includes","setMaxGhosts","charTable","char","specialType","genGlyph","baseGetGlyph","baseGetInterval","genInterval","bind","genDelay","baseGetDelay","State","nGhosts","progress","percent","done","todo","isTyping","isPaused","finished","erasing","addClass","animator","run","emiter","callback","writerData","removeClasses","finish","htmlElement","Emiter","callbacks","start","step","type","i","indexOf","args","cb","eventType","updateString","setAttribute","state","emitEvent","CustomEvent","dispatchEvent","detail","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","next","e","rejected","apply","Char","gl","initialGhosts","index","ghosts","stop","afterGlitchChance","stepsLeft","isSpecialChar","els","ghostsBeforeEl","document","createElement","letterEl","ghostsAfterEl","charEl","innerHTML","textContent","el","appendChildren","_b","append","writeToElement","_c","increase","getDelay","getInterval","lastString","ghostsInLimit","addGhost","removeGhost","getGlyph","insertGhost","ghostsArray","ghost","setupCharTable","createMatching","createPrevious","maxDist","goalTextArray","getGoalStringText","pi","gi","setChar","fi","substring","removeExtraChars","goalStringText","goalArray","resultArray","find","lastIndex","exec","to","stringBefore","slice","htmlToArray","diff","concat","nBefore","nAfter","spans","querySelectorAll","spanElement","prepWordsPlaylist","playList","indexes","wordArray","match","charGroups","ai","sgi","lastGroup","word","reverse","lastResult","ended","loop","group","pop","groupPromises","all","every","executor","prepLettersPlaylist","playOptions","charTableCopy","lastChar","n","Animator","last","rate","running","requestAnimationFrame","frame","t","animate","Queue","texts","isStopped","isLooping","loopInterval","isArray","querySelector","childNodes","node","tagName","endCallback","getWriterData","manageWriting","status","GlitchedWriter","onFinishCallback","lastText","$writer","addCallback","prev","trim","text","queue","queueInterval","write","resume","pause","bool","extend","removeCallback","eraseTo","genGoalStringToErase","preparePropertiesBeforeWrite","playChT","reset","play","returnResult","error","message","goal","previous","pl","padEnd","onStepCallback","queueWrite","create"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GlitchedWriter\"] = factory();\n\telse\n\t\troot[\"GlitchedWriter\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable no-unused-vars */\r\nexport function random(min, max, math) {\r\n    const result = Math.random() * (max - min) + min;\r\n    if (math) {\r\n        // eslint-disable-next-line default-case\r\n        switch (math) {\r\n            case 'floor':\r\n                return Math.floor(result);\r\n            case 'round':\r\n                return Math.round(result);\r\n            case 'ceil':\r\n                return Math.ceil(result);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport const clamp = (min, value, max) => Math.min(Math.max(value, min), max);\r\nexport const deleteRandom = (array) => array.splice(random(0, array.length, 'floor'), 1).length > 0;\r\nexport function getRandom(iterable) {\r\n    return iterable[random(0, iterable.length, 'floor')];\r\n}\r\nexport function filterDuplicates(iterable) {\r\n    const isString = typeof iterable === 'string', result = [];\r\n    new Set(iterable).forEach(x => result.push(x));\r\n    return isString ? result.join('') : result;\r\n}\r\nexport function parseCharset(input) {\r\n    let result;\r\n    // Charset is a string\r\n    if (typeof input === 'string')\r\n        result = input;\r\n    // Charset is an array\r\n    else if (input.length)\r\n        result = input.join('');\r\n    // Charset is a Set\r\n    else\r\n        result = Array.from(input).join('');\r\n    return result;\r\n}\r\nexport const wait = (time) => new Promise(resolve => setTimeout(() => resolve(time), time));\r\nexport function promiseWhile(conditionFunc, actionPromise) {\r\n    const whilst = () => conditionFunc() ? actionPromise().then(whilst) : Promise.resolve();\r\n    return whilst();\r\n}\r\nexport const arrayOfTheSame = (value, length) => new Array(length).fill(value);\r\nexport const isInRange = (min, value, max) => value >= min && value < max;\r\nexport const animateWithClass = (element, className) => {\r\n    element.classList.remove(className);\r\n    // eslint-disable-next-line no-void\r\n    void element.offsetWidth;\r\n    element.classList.add(className);\r\n};\r\nexport function getRandomFromRange(range, round = true) {\r\n    return typeof range === 'number'\r\n        ? range\r\n        : random(...range, round ? 'round' : undefined);\r\n}\r\nexport const coinFlip = (p = 0.5) => Math.random() < p;\r\nexport const letterToLetterItem = (string) => ({\r\n    value: string,\r\n});\r\nexport const stringToLetterItems = (string) => [...string].map(letterToLetterItem);\r\nexport const isSpecialChar = (l) => ['\\t', '\\n', '\\r', '\\f', '\\v', '', ' '].includes(l);\r\nconst findHTMLPattern = '(&(?:[a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});)|(<style.+?>.+?</style>|<script.+?>.+?</script>|<(?:!|/?[a-zA-Z]+).*?/?>)';\r\nexport const wordsRgx = /(&(?:[a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});)|.\\w+,*\\.*\"*\\s?|\\s+|\\S+/gi;\r\nexport function htmlToArray(string) {\r\n    const reg = new RegExp(findHTMLPattern, 'gi'), resultArray = [];\r\n    let find, lastIndex = 0;\r\n    // eslint-disable-next-line no-cond-assign\r\n    while ((find = reg.exec(string))) {\r\n        const from = find.index, to = reg.lastIndex, stringBefore = string.slice(lastIndex, from);\r\n        lastIndex = to;\r\n        stringBefore && resultArray.push(...stringToLetterItems(stringBefore));\r\n        const result = {\r\n            value: find[0],\r\n            type: find[1] !== undefined ? 'html_entity' : 'tag',\r\n        };\r\n        resultArray.push(result);\r\n    }\r\n    string.length > lastIndex &&\r\n        resultArray.push(...stringToLetterItems(string.slice(lastIndex)));\r\n    // return resultArray.map(l =>\r\n    // \tl.type\r\n    // \t\t? l\r\n    // \t\t: {\r\n    // \t\t\t\tvalue: l.value,\r\n    // \t\t\t\ttype: isSpecialChar(l.value) ? 'whitespace' : undefined,\r\n    // \t\t  },\r\n    // )\r\n    return resultArray;\r\n}\r\nexport function filterHtml(string) {\r\n    const reg = new RegExp(findHTMLPattern, 'g');\r\n    return string.replace(reg, '');\r\n}\r\nexport function trim(str, l) {\r\n    if (!l || l.length > 1 || !str)\r\n        return str;\r\n    if (l === ' ')\r\n        return str.trim();\r\n    const reg = new RegExp(`${l}+`, 'g');\r\n    let find, result = str;\r\n    // eslint-disable-next-line no-cond-assign\r\n    while ((find = reg.exec(str))) {\r\n        const from = find.index, to = reg.lastIndex, length = to - from;\r\n        if (from === 0)\r\n            result = result.substring(to);\r\n        else if (to === str.length)\r\n            result = result.substring(result.length - length);\r\n    }\r\n    return result;\r\n}\r\n","export const glyphs = {\r\n    nier: '一二三四五六七八九十百千上下左右中大小月日年早木林山川土空田天生花草虫犬人名女男子目耳口手足見音力気円入出立休先夕本文字学校村町森正水火玉王石竹糸貝車金雨赤青白数多少万半形太細広長点丸交光角計直線矢弱強高同親母父姉兄弟妹自友体毛頭顔首心時曜朝昼夜分週春夏秋冬今新古間方北南東西遠近前後内外場地国園谷野原里市京風雪雲池海岩星室戸家寺通門道話言答声聞語読書記紙画絵図工教晴思考知才理算作元食肉馬牛魚鳥羽鳴麦米茶色黄黒来行帰歩走止活店買売午汽弓回会組船明社切電毎合当台楽公引科歌刀番用何',\r\n    full: 'ABCDĐEFGHIJKLMNOPQRSTUVWXYZabcdđefghijklmnopqrstuvwxyzĄąĆćŻżŹźŃńóŁłАБВГҐДЂЕЁЄЖЗЅИІЇЙЈКЛЉМНЊОПРСТЋУЎФХЦЧЏШЩЪЫЬЭЮЯабвгґдђеёєжзѕиіїйјклљмнњопрстћуўфхцчџшщъыьэюяΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωάΆέΈέΉίϊΐΊόΌύΰϋΎΫΏĂÂÊÔƠƯăâêôơư一二三四五六七八九十百千上下左右中大小月日年早木林山川土空田天生花草虫犬人名女男子目耳口手足見音力気円入出立休先夕本文字学校村町森正水火玉王石竹糸貝車金雨赤青白数多少万半形太細広長点丸交光角計直線矢弱強高同親母父姉兄弟妹自友体毛頭顔首心時曜朝昼夜分週春夏秋冬今新古間方北南東西遠近前後内外場地国園谷野原里市京風雪雲池海岩星室戸家寺通門道話言答声聞語読書記紙画絵図工教晴思考知才理算作元食肉馬牛魚鳥羽鳴麦米茶色黄黒来行帰歩走止活店買売午汽弓回会組船明社切電毎合当台楽公引科歌刀番用何ĂÂÊÔƠƯăâêôơư1234567890‘?’“!”(%)[#]{@}/\\\\&<-+÷×=>$€£¥¢:;,.*•°·…±†‡æ«»¦¯—–~˜¨_øÞ¿▬▭▮▯┐└╛░▒▓○‼⁇⁈⁉‽ℴℵℶℷℸℲ℮ℯ⅁⅂⅃⅄₠₡₢₣₤₥₦₧₨₩₪₫€₭₮₯₰₱₲₳₴₵₶₷₸₹₺₻₼₽₾₿          ',\r\n    letterlike: 'ABCDĐEFGHIJKLMNOPQRSTUVWXYZabcdđefghijklmnopqrstuvwxyzĄąĆćŻżŹźŃńóŁłАБВГҐДЂЕЁЄЖЗЅИІЇЙЈКЛЉМНЊОПРСТЋУЎФХЦЧЏШЩЪЫЬЭЮЯабвгґдђеёєжзѕиіїйјклљмнњопрстћуўфхцчџшщъыьэюяΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωάΆέΈέΉίϊΐΊόΌύΰϋΎΫΏĂÂÊÔƠƯăâêôơưĂÂÊÔƠƯăâêôơư1234567890',\r\n    numbers: '0123456789',\r\n    zalgo: '̴̵̶̷̸̡̢̧̨̛̖̗̘̙̜̝̞̟̠̣̤̥̦̩̪̫̬̭̮̯̰̱̲̳̹̺̻̼͇͈͉͍͎̀́̂̃̄̅̆̇̈̉̊̋̌̍̎̏̐̑̒̓̔̽̾̿̀́͂̓̈́͆͊͋͌̕̚ͅ ͓͔͕͖͙͚͐͑͒͗͛ͣͤͥͦͧͨͩͪͫͬͭͮͯ͘͜͟͢͝͞͠͡͏҉',\r\n    neo: '!<>-_\\\\/[]{}—=+*^?#________',\r\n    uppercase: '1234567890QWERTYUIOPASDFGHJKLZXCVBNM#$%',\r\n};\r\nexport const presets = {\r\n    default: {\r\n        steps: [1, 8],\r\n        interval: [60, 170],\r\n        delay: [0, 2000],\r\n        changeChance: 0.6,\r\n        ghostChance: 0.2,\r\n        maxGhosts: 0.2,\r\n        oneAtATime: 0,\r\n        glyphs: glyphs.full + glyphs.zalgo,\r\n        glyphsFromText: false,\r\n        fillSpace: true,\r\n        mode: 'matching',\r\n        html: false,\r\n        letterize: false,\r\n        endless: false,\r\n        fps: 60,\r\n    },\r\n    nier: {\r\n        maxGhosts: 0,\r\n        ghostChance: 0,\r\n        changeChance: 0.8,\r\n        steps: 3,\r\n        interval: 10,\r\n        delay: 0,\r\n        oneAtATime: 1,\r\n        glyphs: glyphs.nier,\r\n        fillSpace: false,\r\n        glyphsFromText: true,\r\n        mode: 'clear',\r\n    },\r\n    typewriter: {\r\n        interval: [50, 150],\r\n        delay: 0,\r\n        steps: 0,\r\n        changeChance: 0,\r\n        maxGhosts: 0,\r\n        oneAtATime: 1,\r\n        glyphs: '',\r\n        glyphsFromText: false,\r\n        fillSpace: false,\r\n        mode: 'erase_smart',\r\n    },\r\n    terminal: {\r\n        interval: [25, 30],\r\n        delay: [0, 0],\r\n        steps: 0,\r\n        changeChance: 0.5,\r\n        maxGhosts: 0,\r\n        oneAtATime: 1,\r\n        glyphs: '',\r\n        fillSpace: false,\r\n        glyphsFromText: false,\r\n        mode: 'clear',\r\n    },\r\n    zalgo: {\r\n        delay: [0, 3000],\r\n        interval: [10, 35],\r\n        steps: [0, 30],\r\n        maxGhosts: 4.6,\r\n        changeChance: 0.5,\r\n        ghostChance: 0.7,\r\n        glyphs: glyphs.zalgo,\r\n        glyphsFromText: true,\r\n        fillSpace: false,\r\n    },\r\n    neo: {\r\n        interval: [30, 100],\r\n        delay: [0, 1300],\r\n        steps: [4, 7],\r\n        maxGhosts: 0,\r\n        ghostChance: 0,\r\n        changeChance: 1,\r\n        glyphs: glyphs.neo,\r\n        mode: 'normal',\r\n    },\r\n    encrypted: {\r\n        interval: [50, 90],\r\n        delay: [0, 1300],\r\n        steps: [5, 8],\r\n        maxGhosts: 0,\r\n        ghostChance: 0,\r\n        changeChance: 1,\r\n        glyphs: glyphs.uppercase,\r\n        fillSpace: false,\r\n        mode: 'normal',\r\n    },\r\n    bitbybit: {\r\n        interval: [35, 65],\r\n        delay: 180,\r\n        steps: 1,\r\n        maxGhosts: 1,\r\n        ghostChance: 0.1,\r\n        changeChance: 0.7,\r\n        oneAtATime: 'word',\r\n        glyphs: '',\r\n        glyphsFromText: true,\r\n        fillSpace: false,\r\n        mode: 'erase',\r\n    },\r\n    cosmic: {\r\n        steps: [0, 1],\r\n        interval: 30,\r\n        delay: [400, 2400],\r\n        ghostChance: 0,\r\n        changeChance: 0.3,\r\n        maxGhosts: 0,\r\n        glyphs: 'QWERTYUIOPASDFGHJKLZXCVBNM',\r\n        glyphsFromText: false,\r\n        fillSpace: true,\r\n        mode: 'erase',\r\n    },\r\n};\r\n","// eslint-disable-next-line import/no-extraneous-dependencies\r\nimport { parseCharset, filterDuplicates, getRandomFromRange, filterHtml, getRandom, } from '../utils';\r\nimport { presets } from '../presets';\r\nexport default class Options {\r\n    constructor(writer, options) {\r\n        this.writer = writer;\r\n        this.set(options);\r\n    }\r\n    set(options) {\r\n        this.options = Object.assign(Object.assign({}, presets.default), this.parseOptions(options));\r\n        this.updateInternal();\r\n    }\r\n    extend(options) {\r\n        this.options = Object.assign(Object.assign({}, this.options), this.parseOptions(options));\r\n        this.updateInternal();\r\n    }\r\n    parseOptions(options) {\r\n        var _a;\r\n        if (!options)\r\n            return {};\r\n        if (typeof options === 'string')\r\n            return (_a = presets[options]) !== null && _a !== void 0 ? _a : {};\r\n        return options;\r\n    }\r\n    updateInternal() {\r\n        const { options } = this;\r\n        this.glyphs = parseCharset(options.glyphs);\r\n        this.setCharset();\r\n        this.space = options.fillSpace ? ' ' : '';\r\n        if (Number.isInteger(options.oneAtATime))\r\n            this.oneAtATime = options.oneAtATime;\r\n        else if (options.oneAtATime === 'word')\r\n            this.oneAtATime = 'word';\r\n        else\r\n            this.oneAtATime = options.oneAtATime ? 1 : 0;\r\n    }\r\n    setCharset() {\r\n        const { writer } = this;\r\n        let { glyphs } = this;\r\n        if (this.glyphsFromText)\r\n            glyphs += filterDuplicates(writer.previousString +\r\n                (this.html ? filterHtml(writer.goalText) : writer.goalText));\r\n        this.charset = [...glyphs].filter(l => !['\\t', '\\n', '\\r', '\\f', '\\v'].includes(l));\r\n        this.setMaxGhosts();\r\n    }\r\n    setMaxGhosts() {\r\n        const { writer: { charTable }, options: { maxGhosts }, } = this;\r\n        if (Number.isInteger(maxGhosts))\r\n            this.maxGhosts = maxGhosts;\r\n        const { length } = charTable.filter(char => char.specialType !== 'tag');\r\n        this.maxGhosts = Math.round((length || 20) * maxGhosts);\r\n    }\r\n    getGlyph(char) {\r\n        const { options } = this;\r\n        return options.genGlyph\r\n            ? options.genGlyph(char, this.baseGetGlyph)\r\n            : this.baseGetGlyph();\r\n    }\r\n    baseGetGlyph() {\r\n        var _a;\r\n        return (_a = getRandom(this.charset)) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n    get steps() {\r\n        return getRandomFromRange(this.options.steps);\r\n    }\r\n    getInterval(char) {\r\n        const { options, baseGetInterval } = this;\r\n        return options.genInterval\r\n            ? options.genInterval(char, baseGetInterval.bind(this, char))\r\n            : baseGetInterval.call(this, char);\r\n    }\r\n    baseGetInterval(char) {\r\n        let interval = getRandomFromRange(this.options.interval);\r\n        if (char.specialType === 'whitespace')\r\n            interval /= 1.8;\r\n        return interval;\r\n    }\r\n    getDelay(char) {\r\n        const { options } = this;\r\n        return options.genDelay\r\n            ? options.genDelay(char, this.baseGetDelay)\r\n            : this.baseGetDelay();\r\n    }\r\n    baseGetDelay() {\r\n        return getRandomFromRange(this.options.delay);\r\n    }\r\n    get mode() {\r\n        return this.options.mode;\r\n    }\r\n    get html() {\r\n        return this.options.html;\r\n    }\r\n    get endless() {\r\n        return this.options.endless;\r\n    }\r\n    get fps() {\r\n        return this.options.fps;\r\n    }\r\n    get letterize() {\r\n        return this.options.letterize;\r\n    }\r\n    get ghostChance() {\r\n        return this.options.ghostChance;\r\n    }\r\n    get changeChance() {\r\n        return this.options.changeChance;\r\n    }\r\n    get glyphsFromText() {\r\n        return this.options.glyphsFromText;\r\n    }\r\n}\r\n","import { animateWithClass } from '../utils';\r\nexport default class State {\r\n    constructor(writer) {\r\n        this.nGhosts = 0;\r\n        /**\r\n         * Numerical data about progress of writing\r\n         */\r\n        this.progress = {\r\n            percent: 0,\r\n            done: 0,\r\n            todo: 0,\r\n            increase() {\r\n                this.done++;\r\n                this.percent = this.done / this.todo;\r\n            },\r\n            reset(todo) {\r\n                this.percent = 0;\r\n                this.done = 0;\r\n                this.todo = todo;\r\n            },\r\n            finish() {\r\n                this.done = this.todo;\r\n                this.percent = 1;\r\n            },\r\n        };\r\n        this.isTyping = false;\r\n        this.isPaused = false;\r\n        this.finished = true;\r\n        this.erasing = false;\r\n        this.writer = writer;\r\n        this.maxGhosts = this.writer.options.maxGhosts;\r\n    }\r\n    get ghostsInLimit() {\r\n        return this.nGhosts < this.maxGhosts;\r\n    }\r\n    play() {\r\n        this.isTyping = true;\r\n        this.isPaused = false;\r\n        this.finished = false;\r\n        this.addClass();\r\n        this.erasing && this.addClass('gw-erasing');\r\n        this.maxGhosts = this.writer.options.maxGhosts;\r\n        this.writer.animator.run();\r\n        this.writer.emiter.callback('start', this.writer.goalText, this.writer.writerData);\r\n    }\r\n    pause() {\r\n        this.isTyping = false;\r\n        this.isPaused = true;\r\n        this.removeClasses();\r\n    }\r\n    finish() {\r\n        this.progress.finish();\r\n        this.isTyping = false;\r\n        this.finished = true;\r\n        this.removeClasses();\r\n    }\r\n    addClass(className = 'gw-writing') {\r\n        animateWithClass(this.writer.htmlElement, className);\r\n    }\r\n    removeClasses() {\r\n        this.writer.htmlElement.classList.remove('gw-writing', 'gw-erasing');\r\n    }\r\n}\r\n","import { filterHtml } from '../utils';\r\nexport default class Emiter {\r\n    constructor(writer) {\r\n        this.callbacks = {\r\n            start: [],\r\n            step: [],\r\n            finish: [],\r\n        };\r\n        this.writer = writer;\r\n    }\r\n    addCallback(type, callback) {\r\n        this.callbacks[type].push(callback);\r\n    }\r\n    removeCallback(type, callback) {\r\n        const array = this.callbacks[type], i = array.indexOf(callback);\r\n        if (i === -1)\r\n            return false;\r\n        array.splice(i, 1);\r\n        return true;\r\n    }\r\n    callback(type, ...args) {\r\n        this.callbacks[type].forEach(cb => cb(...args));\r\n    }\r\n    call(eventType) {\r\n        const { writer } = this;\r\n        writer.updateString();\r\n        const { writerData, string } = writer;\r\n        // for letterize: update data attribute every step\r\n        if (writer.options.letterize)\r\n            writer.htmlElement.setAttribute('data-gw-string', writer.options.html ? filterHtml(string) : string);\r\n        // ON STEP\r\n        if (eventType === 'step')\r\n            return this.callback('step', string, writerData);\r\n        // ON FINISH\r\n        writer.state.finish();\r\n        // change state to finished but do not fire callbacks\r\n        if (writer.state.erasing)\r\n            return;\r\n        this.callback('finish', string, writerData);\r\n        this.emitEvent();\r\n    }\r\n    emitEvent() {\r\n        const { htmlElement, writerData } = this.writer;\r\n        if (typeof CustomEvent === 'undefined')\r\n            return;\r\n        htmlElement.dispatchEvent(new CustomEvent('gw-finished', { detail: writerData }));\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { random, deleteRandom, wait, promiseWhile, coinFlip, isSpecialChar, animateWithClass, } from '../utils';\r\nexport default class Char {\r\n    constructor(writer, l, gl, initialGhosts = '', specialType, index) {\r\n        this.ghosts = [[], []];\r\n        this.stop = false;\r\n        this.afterGlitchChance = 0;\r\n        this.writer = writer;\r\n        const { options } = writer;\r\n        this.index = index;\r\n        this.l = l;\r\n        this.gl = gl;\r\n        this.specialType = specialType;\r\n        this.ghosts[0] = [...initialGhosts];\r\n        this.writer.state.nGhosts += initialGhosts.length;\r\n        this.stepsLeft = options.steps;\r\n        if (specialType === 'tag')\r\n            this.stepsLeft = 0;\r\n        else if (isSpecialChar(gl))\r\n            this.specialType = 'whitespace';\r\n        this.afterGlitchChance =\r\n            (options.ghostChance + options.changeChance) / 3.7;\r\n        if (writer.options.letterize) {\r\n            this.els = {\r\n                ghostsBeforeEl: document.createElement('span'),\r\n                letterEl: document.createElement('span'),\r\n                ghostsAfterEl: document.createElement('span'),\r\n            };\r\n            this.els.ghostsBeforeEl.className = 'gw-ghosts';\r\n            this.els.ghostsAfterEl.className = 'gw-ghosts';\r\n            this.els.letterEl.className = 'gw-letter';\r\n        }\r\n    }\r\n    get string() {\r\n        const { l, ghosts } = this;\r\n        return ghosts[0].join('') + l + ghosts[1].join('');\r\n    }\r\n    get finished() {\r\n        const { l, gl, ghosts } = this;\r\n        return ((l === gl && ghosts[0].length === 0 && ghosts[1].length === 0) ||\r\n            this.specialType === 'tag');\r\n    }\r\n    writeToElement() {\r\n        if (!this.els)\r\n            return;\r\n        const { ghostsBeforeEl, ghostsAfterEl, letterEl, charEl } = this.els;\r\n        letterEl.innerHTML = this.l;\r\n        ghostsBeforeEl.textContent = this.ghosts[0].join('');\r\n        ghostsAfterEl.textContent = this.ghosts[1].join('');\r\n        charEl && animateWithClass(charEl, 'gw-changed');\r\n    }\r\n    set spanElement(el) {\r\n        if (!this.els)\r\n            return;\r\n        this.els.charEl = el;\r\n        this.appendChildren();\r\n    }\r\n    appendChildren() {\r\n        var _a, _b;\r\n        (_b = (_a = this.els) === null || _a === void 0 ? void 0 : _a.charEl) === null || _b === void 0 ? void 0 : _b.append(this.els.ghostsBeforeEl, this.els.letterEl, this.els.ghostsAfterEl);\r\n        this.writeToElement();\r\n    }\r\n    type() {\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { options, state, emiter } = this.writer;\r\n            if (this.specialType === 'tag') {\r\n                this.l = this.gl;\r\n                emiter.call('step');\r\n                state.progress.increase();\r\n                return true;\r\n            }\r\n            const loop = () => __awaiter(this, void 0, void 0, function* () {\r\n                yield wait(options.getInterval(this));\r\n                const lastString = this.string;\r\n                this.step();\r\n                if (lastString !== this.string) {\r\n                    emiter.call('step');\r\n                    this.writeToElement();\r\n                }\r\n                !options.endless && this.stepsLeft--;\r\n            });\r\n            yield wait(options.getDelay(this));\r\n            yield promiseWhile(() => (!this.finished || options.endless) &&\r\n                !state.isPaused &&\r\n                !this.stop, loop);\r\n            if (this.finished) {\r\n                state.progress.increase();\r\n                (_b = (_a = this.els) === null || _a === void 0 ? void 0 : _a.charEl) === null || _b === void 0 ? void 0 : _b.classList.add('gw-finished');\r\n                (_c = this.els) === null || _c === void 0 ? void 0 : _c.letterEl.classList.remove('gw-glitched');\r\n            }\r\n            return this.finished;\r\n        });\r\n    }\r\n    step() {\r\n        var _a, _b;\r\n        const { writer } = this;\r\n        if ((this.stepsLeft > 0 && this.l !== this.gl) ||\r\n            (coinFlip(this.afterGlitchChance) &&\r\n                this.specialType !== 'whitespace') ||\r\n            writer.options.endless) {\r\n            /**\r\n             * IS GROWING\r\n             */\r\n            const { ghostChance, changeChance } = writer.options;\r\n            if (coinFlip(ghostChance)) {\r\n                if (writer.state.ghostsInLimit)\r\n                    this.addGhost();\r\n                else\r\n                    this.removeGhost();\r\n            }\r\n            if (coinFlip(changeChance)) {\r\n                (_a = this.els) === null || _a === void 0 ? void 0 : _a.letterEl.classList.add('gw-glitched');\r\n                this.l = writer.options.getGlyph(this);\r\n            }\r\n        }\r\n        else if (!this.finished) {\r\n            /**\r\n             * IS SHRINKING\r\n             */\r\n            (_b = this.els) === null || _b === void 0 ? void 0 : _b.letterEl.classList.remove('gw-glitched');\r\n            this.l = this.gl;\r\n            this.removeGhost();\r\n        }\r\n    }\r\n    addGhost() {\r\n        const { writer, ghosts } = this, l = writer.options.getGlyph(this);\r\n        writer.state.nGhosts++;\r\n        coinFlip() ? insertGhost(ghosts[0], l) : insertGhost(ghosts[1], l);\r\n    }\r\n    removeGhost() {\r\n        const { writer, ghosts } = this, deleted = coinFlip() && ghosts[0].length > 0\r\n            ? deleteRandom(ghosts[0])\r\n            : deleteRandom(ghosts[1]);\r\n        if (deleted)\r\n            writer.state.nGhosts--;\r\n    }\r\n}\r\nfunction insertGhost(ghostsArray, ghost) {\r\n    const { length } = ghostsArray;\r\n    ghostsArray.splice(random(0, length, 'floor'), 0, ghost);\r\n}\r\n","import Char from '../modules/char';\r\nimport { arrayOfTheSame, htmlToArray, stringToLetterItems as textToLetterItems, } from '../utils';\r\nexport default function setupCharTable() {\r\n    const { charTable, options } = this;\r\n    // For \"clear\" mode char table will be prepared as starting from blank\r\n    const from = options.mode === 'clear' && this.state.finished ? '' : this.previousString;\r\n    // Clear Char Table -> stop all chars and remove them from char table\r\n    charTable.forEach(char => (char.stop = true));\r\n    this.charTable = [];\r\n    options.mode === 'matching'\r\n        ? createMatching.call(this, from)\r\n        : createPrevious.call(this, from);\r\n}\r\nfunction createMatching(from) {\r\n    const maxDist = Math.min(Math.ceil(this.options.maxGhosts / 2), 5), goalTextArray = getGoalStringText.call(this, from);\r\n    let pi = -1;\r\n    goalTextArray.forEach((gl, gi) => {\r\n        pi++;\r\n        if (gl.type === 'tag') {\r\n            pi--;\r\n            setChar.call(this, gi, '', gl);\r\n            return;\r\n        }\r\n        const fi = gl.value !== '' ? from.indexOf(gl.value, pi) : -1;\r\n        if (fi !== -1 && fi - pi <= maxDist) {\r\n            const ghosts = from.substring(pi, fi);\r\n            setChar.call(this, gi, gl.value, gl, ghosts);\r\n            pi = fi;\r\n        }\r\n        else\r\n            setChar.call(this, gi, from[pi], gl);\r\n    });\r\n    removeExtraChars(this.charTable, goalTextArray.length);\r\n}\r\nfunction createPrevious(from) {\r\n    const goalStringText = getGoalStringText.call(this, from);\r\n    let pi = -1;\r\n    goalStringText.forEach((gl, gi) => {\r\n        pi++;\r\n        if (gl.type === 'tag') {\r\n            pi--;\r\n            setChar.call(this, gi, '', gl);\r\n            return;\r\n        }\r\n        setChar.call(this, gi, from[pi], gl);\r\n    });\r\n    removeExtraChars(this.charTable, goalStringText.length);\r\n}\r\nfunction getGoalStringText(from) {\r\n    const { options, goalText } = this, goalArray = options.html\r\n        ? htmlToArray(goalText)\r\n        : textToLetterItems(goalText), diff = Math.max(0, from.length - goalArray.length);\r\n    if (options.oneAtATime)\r\n        return goalArray.concat(textToLetterItems(arrayOfTheSame('', diff)));\r\n    const nBefore = Math.ceil(diff / 2), nAfter = Math.floor(diff / 2);\r\n    return textToLetterItems(arrayOfTheSame('', nBefore)).concat(goalArray, textToLetterItems(arrayOfTheSame('', nAfter)));\r\n}\r\nfunction setChar(i, l, gl, ghosts) {\r\n    const { charTable, options } = this;\r\n    charTable.push(new Char(this, l !== null && l !== void 0 ? l : '', gl.value || options.space, ghosts, gl.type, i));\r\n}\r\nfunction removeExtraChars(charTable, from) {\r\n    charTable.splice(from, charTable.length - from);\r\n}\r\n","export default function letterize() {\r\n    if (!this.options.letterize)\r\n        return;\r\n    const html = this.charTable\r\n        .map(({ specialType, gl }) => specialType === 'tag' ? gl : '<span class=\"gw-char\"></span>')\r\n        .join('');\r\n    this.htmlElement.innerHTML = html;\r\n    const spans = this.htmlElement.querySelectorAll('span.gw-char');\r\n    let i = 0;\r\n    this.charTable.forEach(char => {\r\n        if (char.specialType === 'tag')\r\n            return;\r\n        char.spanElement = spans[i];\r\n        i++;\r\n    });\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { promiseWhile, wordsRgx } from '../../utils';\r\n/**\r\n * ONE WORD AT A TIME\r\n */\r\nexport default function prepWordsPlaylist(playList) {\r\n    const { charTable, state } = this;\r\n    // indexes of chars in chartable that are normal letters\r\n    const indexes = [];\r\n    let wordArray;\r\n    /**\r\n     * Scope for separating words\r\n     */\r\n    {\r\n        const filteredTable = charTable.filter((char, i) => {\r\n            if (char.specialType === 'tag' ||\r\n                char.specialType === 'html_entity')\r\n                return false;\r\n            indexes.push(i);\r\n            return true;\r\n        }), \r\n        // I want to only find words in the normal text\r\n        text = filteredTable.map(char => char.gl).join('');\r\n        wordArray = text.match(wordsRgx);\r\n    }\r\n    /**\r\n     * Scope for greating groups\r\n     */\r\n    const charGroups = [];\r\n    {\r\n        // set of index variables\r\n        // fi - index of (not) filtered chars\r\n        // gi - index of all chars\r\n        // sgi - steady gi - for detecting when gi grows more than 1\r\n        let fi = -1, ai = -1, sgi = -1;\r\n        const lastGroup = () => charGroups[charGroups.length - 1];\r\n        wordArray === null || wordArray === void 0 ? void 0 : wordArray.forEach(word => {\r\n            charGroups.push([]);\r\n            [...word].forEach(() => {\r\n                fi++;\r\n                ai = indexes[fi];\r\n                sgi++;\r\n                // handling filtered chars before current char\r\n                if (sgi !== ai) {\r\n                    for (let i = sgi; i < ai; i++) {\r\n                        lastGroup().push(charTable[i]);\r\n                    }\r\n                    sgi = ai;\r\n                }\r\n                lastGroup().push(charTable[ai]);\r\n            });\r\n        });\r\n        // Adds the rest of the chartable chars\r\n        if (!charGroups.length)\r\n            charGroups.push([]);\r\n        for (let i = ai + 1; i < charTable.length; i++) {\r\n            lastGroup().push(charTable[i]);\r\n        }\r\n    }\r\n    // so i can use .pop() and get the first group\r\n    charGroups.reverse();\r\n    let lastResult = true, ended = false;\r\n    const loop = () => __awaiter(this, void 0, void 0, function* () {\r\n        var _a;\r\n        const group = charGroups.pop();\r\n        if (!group)\r\n            return (ended = true);\r\n        const groupPromises = group.map(char => char.type());\r\n        lastResult =\r\n            (_a = (yield Promise.all(groupPromises)).every(result => result)) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n    const executor = () => __awaiter(this, void 0, void 0, function* () {\r\n        yield promiseWhile(() => !ended && lastResult && !state.isPaused, loop);\r\n        return ended && lastResult && !state.isPaused;\r\n    });\r\n    playList.push(executor());\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { promiseWhile } from '../../utils';\r\nexport default function prepLettersPlaylist(playList, playOptions) {\r\n    var _a;\r\n    const { charTable, state, options } = this, reverse = (_a = playOptions === null || playOptions === void 0 ? void 0 : playOptions.reverse) !== null && _a !== void 0 ? _a : false, charTableCopy = reverse ? [...charTable] : [...charTable].reverse();\r\n    // Char executor - runs a loop, typing one char at a time\r\n    // It is possible to run multiple of them at the same time\r\n    const executor = () => __awaiter(this, void 0, void 0, function* () {\r\n        let lastResult = true, ended = false;\r\n        const loop = () => __awaiter(this, void 0, void 0, function* () {\r\n            var _b;\r\n            const lastChar = charTableCopy.pop();\r\n            if (!lastChar)\r\n                ended = true;\r\n            else\r\n                lastResult = (_b = (yield lastChar.type())) !== null && _b !== void 0 ? _b : false;\r\n        });\r\n        yield promiseWhile(() => !ended && lastResult && !state.isPaused, loop);\r\n        return ended && lastResult && !state.isPaused;\r\n    });\r\n    // Add as many executors as needed to the playList\r\n    for (let n = 0; n < options.oneAtATime; n++) {\r\n        playList.push(executor());\r\n    }\r\n}\r\n","import { filterHtml } from '../utils';\r\nexport default class Animator {\r\n    constructor(writer) {\r\n        this.last = 0;\r\n        this.rate = 16;\r\n        this.running = false;\r\n        this.writer = writer;\r\n    }\r\n    run() {\r\n        // animator runs only for non-letterize mode\r\n        if (this.running || this.writer.options.letterize)\r\n            return;\r\n        this.rate = Math.floor(1000 / this.writer.options.fps);\r\n        this.running = true;\r\n        requestAnimationFrame(this.frame.bind(this));\r\n    }\r\n    frame(t) {\r\n        // exit the loop if the writer isn't writing anymore\r\n        if (!this.writer.state.isTyping) {\r\n            this.animate.call(this);\r\n            return (this.running = false);\r\n        }\r\n        // keep it above specified refresh rate\r\n        if (!this.last)\r\n            this.last = t;\r\n        if (t - this.last < this.rate)\r\n            return requestAnimationFrame(this.frame.bind(this));\r\n        // animate text\r\n        this.animate.call(this);\r\n        // request next frame\r\n        this.last = t;\r\n        return requestAnimationFrame(this.frame.bind(this));\r\n    }\r\n    animate() {\r\n        const { htmlElement, string } = this.writer;\r\n        if (this.writer.options.html)\r\n            htmlElement.innerHTML = string;\r\n        else\r\n            htmlElement.textContent = string;\r\n        htmlElement.setAttribute('data-gw-string', this.writer.options.html ? filterHtml(string) : string);\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { wait } from '../utils';\r\nexport default class Queue {\r\n    constructor(writer, texts, interval = 800, loop = false) {\r\n        this.isStopped = false;\r\n        this.isLooping = false;\r\n        this.loopInterval = 0;\r\n        this.index = -1;\r\n        this.writer = writer;\r\n        this.interval = interval;\r\n        // Setup texts\r\n        if (Array.isArray(texts))\r\n            this.texts = texts;\r\n        else {\r\n            // If passed html element\r\n            // get child paragraphs as sequent texts to write\r\n            let el;\r\n            if (typeof texts === 'object')\r\n                el = texts;\r\n            else\r\n                el = document.querySelector(texts);\r\n            this.texts = [];\r\n            el === null || el === void 0 ? void 0 : el.childNodes.forEach(node => {\r\n                const { tagName, innerHTML } = node;\r\n                tagName === 'P' &&\r\n                    innerHTML !== undefined &&\r\n                    this.texts.push(innerHTML);\r\n            });\r\n        }\r\n        // Setup looping settings\r\n        if (typeof loop === 'boolean')\r\n            this.isLooping = loop;\r\n        else if (typeof loop === 'function')\r\n            this.endCallback = loop;\r\n        else {\r\n            this.isLooping = true;\r\n            this.loopInterval = loop;\r\n        }\r\n        this.loop();\r\n    }\r\n    stop() {\r\n        this.isStopped = true;\r\n    }\r\n    resume() {\r\n        this.index--;\r\n        this.isStopped = false;\r\n        this.writer.state.isPaused = false;\r\n        this.loop();\r\n    }\r\n    loop() {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.texts.length)\r\n                return;\r\n            this.index++;\r\n            if (this.index >= this.texts.length) {\r\n                if (this.isLooping) {\r\n                    yield wait(this.loopInterval);\r\n                    this.index = 0;\r\n                }\r\n                else\r\n                    return (_a = this.endCallback) === null || _a === void 0 ? void 0 : _a.call(this, this.writer.string, this.writer.getWriterData('SUCCESS', \"The queue has reached it's end.\"));\r\n            }\r\n            if (this.isStopped || this.writer.state.isPaused)\r\n                return;\r\n            const result = yield this.writer.manageWriting(this.texts[this.index]);\r\n            if ((result === null || result === void 0 ? void 0 : result.status) !== 'SUCCESS' || this.writer.state.isPaused)\r\n                return;\r\n            yield wait(this.interval);\r\n            this.loop();\r\n        });\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n// eslint-disable-next-line import/no-extraneous-dependencies\r\nimport Options from './modules/options';\r\nimport State from './modules/state';\r\nimport Emiter from './modules/emiter';\r\nimport { wait, filterHtml } from './utils';\r\nimport { presets, glyphs } from './presets';\r\nimport setupCharTable from './functions/setupCharTable';\r\nimport letterize from './functions/letterize';\r\nimport prepWordsPlaylist from './functions/playlist/words';\r\nimport prepLettersPlaylist from './functions/playlist/letters';\r\nimport Animator from './modules/animator';\r\nimport Queue from './modules/queue';\r\nexport default class GlitchedWriter {\r\n    /**\r\n     * Create new instance of Glitched Writer, that manages writing text to one HTML Element. Few writers can possess the same HTML Element, but don't write with them at the same time.\r\n     * Use .write(string) method to start writing.\r\n     * @param htmlElement HTML Element OR a Selector string (eg. '.text')\r\n     * @param options Options object (eg. { html: true, ... }) OR preset name (eg. 'zalgo').\r\n     * @param onFinishCallback Callback, that will be triggered when each writing finishes. Params passed: string & writer data.\r\n     */\r\n    constructor(htmlElement, options, onFinishCallback) {\r\n        var _a;\r\n        this.charTable = [];\r\n        this.goalText = '';\r\n        this.lastText = '';\r\n        this.string = '';\r\n        if (!htmlElement)\r\n            this.htmlElement = document.createElement('span');\r\n        else if (typeof htmlElement === 'string') {\r\n            this.htmlElement =\r\n                (_a = document.querySelector(htmlElement)) !== null && _a !== void 0 ? _a : document.createElement('span');\r\n        }\r\n        else\r\n            this.htmlElement = htmlElement;\r\n        this.htmlElement.$writer = this;\r\n        this.options = new Options(this, options);\r\n        this.state = new State(this);\r\n        this.emiter = new Emiter(this);\r\n        if (onFinishCallback)\r\n            this.emiter.addCallback('finish', onFinishCallback);\r\n        this.animator = new Animator(this);\r\n        this.string = this.previousString;\r\n    }\r\n    updateString() {\r\n        this.string = this.charTable.map(char => char.string).join('');\r\n    }\r\n    get previousString() {\r\n        let prev = this.htmlElement.textContent;\r\n        if (typeof prev !== 'string')\r\n            prev = this.options.html ? filterHtml(this.string) : this.string;\r\n        prev = prev.trim();\r\n        return prev;\r\n    }\r\n    /**\r\n     * All the data, about current state of the writer instance.\r\n     */\r\n    get writerData() {\r\n        const writer = this, { options, state, string } = this;\r\n        return {\r\n            string,\r\n            writer,\r\n            options,\r\n            state,\r\n        };\r\n    }\r\n    /**\r\n     * Main function of Glitched Writer. It orders writer to start typing passed string. Can be called multiple times after each other, or even during writing.\r\n     * @param text text, that will get written.\r\n     * @returns Promise, with writer data result\r\n     */\r\n    write(text) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.queue) {\r\n                this.queue.stop();\r\n                delete this.queue;\r\n            }\r\n            return this.manageWriting(text);\r\n        });\r\n    }\r\n    /**\r\n     * Order Glitched writer to write sequence of texts.\r\n     * @param texts - Array of sequent strings to write.\r\n     *\r\n     * You can also pass a `query selector` or a `HTMLElement`.\r\n     * The content of children `<p>` tags will make the text queue\r\n     * @param queueInterval - Time to wait between writing each texts [ms]\r\n     * @param loop - boolean | Callback | number - What to do when the queue has ended.\r\n     * - false -> stop;\r\n     * - true -> continue looping;\r\n     * - Callback -> fire the callback and stop.\r\n     * - number -> wait that many ms and then continue\r\n     */\r\n    queueWrite(texts, queueInterval, loop) {\r\n        if (this.queue) {\r\n            this.queue.stop();\r\n            delete this.queue;\r\n        }\r\n        this.queue = new Queue(this, texts, queueInterval, loop);\r\n    }\r\n    /**\r\n     * Add text to end method. Orders writer to write same string as previous, but with this added at the end.\r\n     * @param string text that will get added\r\n     * @returns Promise, with writer data result\r\n     */\r\n    add(string) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { previousString } = this;\r\n            return this.write(previousString + string);\r\n        });\r\n    }\r\n    /**\r\n     * Remove last n-letters method. Orders writer to write same string as previous, but without n-letters at the end.\r\n     * @param n number of letters to remove.\r\n     * @returns Promise, with writer data result\r\n     */\r\n    remove(n) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { previousString } = this, array = Array.from(previousString);\r\n            array.splice(-n);\r\n            // return this.write(array.join(''), { erase: true })\r\n            return this.write(array.join(''));\r\n        });\r\n    }\r\n    /**\r\n     * Resume last writing order.\r\n     * @returns Promise, with writer data result\r\n     */\r\n    play() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.state.isPaused)\r\n                return this.getWriterData('ERROR', \"The writer isn't paused.\");\r\n            if (this.queue) {\r\n                this.queue.resume();\r\n                return this.getWriterData('SUCCESS', 'The queue was resumed');\r\n            }\r\n            return this.manageWriting(null);\r\n        });\r\n    }\r\n    /**\r\n     * Pause current writer task.\r\n     */\r\n    pause() {\r\n        this.state.pause();\r\n    }\r\n    /**\r\n     * Shorthand for changing endless option value\r\n     * @param bool goal state\r\n     */\r\n    endless(bool) {\r\n        this.options.extend({ endless: bool });\r\n    }\r\n    /**\r\n     * Use this to add callback to one of the writer events\r\n     *\r\n     * save callback in a variable first if you want to remove it later.\r\n     * @param type \"start\" | \"step\" | \"finish\"\r\n     * @param callback your callback function: (string, writerData) => {}\r\n     * @returns GlitchedWriter instance (this)\r\n     */\r\n    addCallback(type, callback) {\r\n        this.emiter.addCallback(type, callback);\r\n        return this;\r\n    }\r\n    /**\r\n     * Use this to remove added callback\r\n     * @param type \"start\" | \"step\" | \"finish\"\r\n     * @param callback variable pointing to your function\r\n     * @returns GlitchedWriter instance (this)\r\n     */\r\n    removeCallback(type, callback) {\r\n        this.emiter.removeCallback(type, callback);\r\n        return this;\r\n    }\r\n    // private logCharTable() {\r\n    // \tconsole.table(\r\n    // \t\tthis.charTable.map(\r\n    // \t\t\t({ ghostsBefore, ghostsAfter, l, gl, isTag, isWhitespace }) => [\r\n    // \t\t\t\tghostsBefore.join(''),\r\n    // \t\t\t\tghostsAfter.join(''),\r\n    // \t\t\t\tl,\r\n    // \t\t\t\tgl,\r\n    // \t\t\t\t(isTag && 'TAG') || (isWhitespace && 'Whitespace'),\r\n    // \t\t\t],\r\n    // \t\t),\r\n    // \t)\r\n    // }\r\n    manageWriting(text) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (text !== null)\r\n                this.lastText = text;\r\n            // Erasing first\r\n            if (['erase_smart', 'erase'].includes(this.options.mode) &&\r\n                (this.state.finished || this.state.erasing)) {\r\n                this.state.erasing = true;\r\n                const eraseTo = this.genGoalStringToErase(this.lastText);\r\n                this.preparePropertiesBeforeWrite(eraseTo);\r\n                yield this.playChT({\r\n                    reverse: this.options.oneAtATime !== 0,\r\n                });\r\n                // If erasing did not finish for some reason\r\n                // Like it was paused\r\n                if (!this.state.finished)\r\n                    return this.getWriterData('ERROR', 'Erasing did not finish.');\r\n                this.state.erasing = false;\r\n            }\r\n            this.preparePropertiesBeforeWrite(this.lastText);\r\n            // this.logCharTable()\r\n            this.pause();\r\n            return this.playChT();\r\n        });\r\n    }\r\n    preparePropertiesBeforeWrite(text) {\r\n        /* PREPARE PROPERTIES */\r\n        this.goalText = text;\r\n        this.state.nGhosts = 0;\r\n        this.options.setCharset();\r\n        setupCharTable.call(this);\r\n        this.state.progress.reset(this.charTable.length);\r\n        letterize.call(this);\r\n    }\r\n    playChT(playOptions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const playList = [], { charTable, state, options } = this;\r\n            if (state.isTyping)\r\n                return this.getWriterData('ERROR', `The writer is already typing.`);\r\n            state.play();\r\n            // N LETTERS AT A TIME\r\n            if (options.oneAtATime > 0)\r\n                prepLettersPlaylist.call(this, playList, playOptions);\r\n            // BY WORDS\r\n            else if (options.oneAtATime === 'word')\r\n                prepWordsPlaylist.call(this, playList);\r\n            // NORMAL\r\n            else\r\n                charTable.forEach(char => playList.push(char.type()));\r\n            /**\r\n             * Play Playlist\r\n             * and return the result\r\n             */\r\n            try {\r\n                const finished = (yield Promise.all(playList)).every(result => result);\r\n                return this.returnResult(finished);\r\n            }\r\n            catch (error) {\r\n                return this.getWriterData('ERROR', 'Writer encountered an error.', error);\r\n            }\r\n        });\r\n    }\r\n    returnResult(finished) {\r\n        finished ? this.emiter.call('finish') : this.emiter.call('step');\r\n        return finished\r\n            ? this.getWriterData('SUCCESS', `The writer finished typing.`)\r\n            : this.getWriterData('ERROR', `Writer failed to finish typing.`);\r\n    }\r\n    getWriterData(status, message, error) {\r\n        const { writerData } = this;\r\n        return Object.assign(Object.assign({}, writerData), { status,\r\n            message,\r\n            error });\r\n    }\r\n    genGoalStringToErase(goal) {\r\n        var _a;\r\n        const { previousString: previous } = this;\r\n        let result = '';\r\n        if (this.options.mode === 'erase_smart') {\r\n            // Do not erase matching with previous letters\r\n            for (let i = 0; i < goal.length; i++) {\r\n                const gl = goal[i], pl = (_a = previous[i]) !== null && _a !== void 0 ? _a : '';\r\n                if (gl === pl)\r\n                    result += pl;\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n        const diff = Math.max(goal.length - result.length, 0);\r\n        if (diff > 0 && this.options.space === ' ')\r\n            result = result.padEnd(diff + result.length, ' ');\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * One time use, standalone write function. Used to order a temporary Glitched Writer instance to animate content of html element to chosen text.\r\n * @param string text, that will get written.\r\n * @param htmlElement HTML Element OR a Selector string (eg. '.text')\r\n * @param options Options object (eg. { html: true, ... }) OR preset name (eg. 'zalgo').\r\n * @param onStepCallback Callback, that will be triggered on every step. Params passed: string & writer data.\r\n * @param onFinishCallback Callback, that will be triggered when each writing finishes. Params passed: string & writer data.\r\n * @returns Promise, with writer data result\r\n */\r\nexport function write(string, htmlElement, options, onStepCallback, onFinishCallback) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const writer = new GlitchedWriter(htmlElement, options, onFinishCallback);\r\n        if (onStepCallback)\r\n            writer.addCallback('step', onStepCallback);\r\n        return writer.write(string);\r\n    });\r\n}\r\n/**\r\n * Standalone queueWrite function. Used to\r\n * @param texts - Array of strings to write.\r\n *\r\n * You can also pass a `selector` or a `HTMLElement`.\r\n * The content of children `<p>` tags will make the text queue\r\n * @param htmlElement Writer HTML Element OR a Selector string (eg. '.text')\r\n * @param options Options object (eg. { html: true, ... }) OR preset name (eg. 'zalgo').\r\n * @param queueInterval - Time to wait between writing each texts [ms]\r\n * @param loop - boolean | Callback | number - What to do when the queue has ended.\r\n * - false -> stop;\r\n * - true -> continue looping;\r\n * - Callback -> stop and fire the callback.\r\n * - number -> wait number ms and then continue\r\n * @param onStepCallback Callback, that will be triggered on every step. Params passed: string & writer data.\r\n * @param onFinishCallback Callback, that will be triggered when each writing finishes. Params passed: string & writer data.\r\n * @returns created GlitchedWriter instance\r\n */\r\nexport function queueWrite(texts, htmlElement, options, queueInterval, loop, onStepCallback, onFinishCallback) {\r\n    const writer = new GlitchedWriter(htmlElement, options, onFinishCallback);\r\n    if (onStepCallback)\r\n        writer.addCallback('step', onStepCallback);\r\n    writer.queueWrite(texts, queueInterval, loop);\r\n    return writer;\r\n}\r\n/**\r\n * A way to create new Writer without having to rely on defult export.\r\n * @param htmlElement HTML Element OR a Selector string (eg. '.text')\r\n * @param options Options object (eg. { html: true, ... }) OR preset name (eg. 'zalgo').\r\n * @param onFinishCallback Callback, that will be triggered when each writing finishes. Params passed: string & writer data.\r\n * @returns GlitchedWriter Class Instance\r\n */\r\nexport const create = (htmlElement, options, onFinishCallback) => new GlitchedWriter(htmlElement, options, onFinishCallback);\r\nexport { presets, glyphs, wait };\r\n"],"sourceRoot":""}