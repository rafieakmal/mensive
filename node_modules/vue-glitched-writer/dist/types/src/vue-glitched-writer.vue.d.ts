import GlitchedWriterClass, { Callback } from 'glitched-writer';
declare const _default: import("vue-demi").DefineComponent<{
    text: {
        type: (StringConstructor | ArrayConstructor)[];
        required: true;
    };
    pause: {
        type: BooleanConstructor;
        default: boolean;
    };
    preset: {
        type: StringConstructor;
        default: string;
    };
    options: {
        type: ObjectConstructor;
        default: () => void;
    };
    queue: {
        type: ObjectConstructor;
        default: () => void;
    };
    silent: {
        type: BooleanConstructor;
        default: boolean;
    };
    tag: {
        type: StringConstructor;
        default: string;
    };
}, {
    writer: import("vue-demi").Ref<{
        htmlElement: import("glitched-writer/lib/esm/types").HTMLWriterElement;
        options: {
            glyphs: string;
            charset: string[];
            space: string;
            oneAtATime: number | "word";
            maxGhosts: number;
            set: (options?: "default" | Partial<import("glitched-writer/lib/esm/types").AllCustomOptions> | "nier" | "typewriter" | "terminal" | "zalgo" | "neo" | "encrypted" | "bitbybit" | "cosmic" | null | undefined) => void;
            extend: (options?: "default" | Partial<import("glitched-writer/lib/esm/types").AllCustomOptions> | "nier" | "typewriter" | "terminal" | "zalgo" | "neo" | "encrypted" | "bitbybit" | "cosmic" | null | undefined) => void;
            parseOptions: (options?: "default" | Partial<import("glitched-writer/lib/esm/types").AllCustomOptions> | "nier" | "typewriter" | "terminal" | "zalgo" | "neo" | "encrypted" | "bitbybit" | "cosmic" | null | undefined) => Partial<import("glitched-writer/lib/esm/types").AllCustomOptions>;
            setCharset: () => void;
            setMaxGhosts: () => void;
            getGlyph: (char: import("glitched-writer/lib/esm/modules/char").default) => string;
            readonly steps: number;
            getInterval: (char: import("glitched-writer/lib/esm/modules/char").default) => number;
            getDelay: (char: import("glitched-writer/lib/esm/modules/char").default) => number;
            readonly mode: "matching" | "normal" | "erase" | "erase_smart" | "clear";
            readonly html: boolean;
            readonly endless: boolean;
            readonly fps: number;
            readonly letterize: boolean;
            readonly ghostChance: number;
            readonly changeChance: number;
            readonly glyphsFromText: boolean;
        };
        state: {
            writer: any;
            nGhosts: number;
            maxGhosts: number;
            progress: {
                percent: number;
                done: number;
                todo: number;
                increase: () => void;
                reset: (todo: number) => void;
                finish: () => void;
            };
            isTyping: boolean;
            isPaused: boolean;
            finished: boolean;
            erasing: boolean;
            readonly ghostsInLimit: boolean;
            play: () => void;
            pause: () => void;
            finish: () => void;
            addClass: (className?: "gw-writing" | "gw-erasing" | undefined) => void;
            removeClasses: () => void;
        };
        emiter: {
            writer: any;
            callbacks: {
                start: Callback[];
                step: Callback[];
                finish: Callback[];
            };
            addCallback: (type: import("glitched-writer/lib/esm/types").CallbackType, callback: Callback) => void;
            removeCallback: (type: import("glitched-writer/lib/esm/types").CallbackType, callback: Callback) => boolean;
            callback: (type: import("glitched-writer/lib/esm/types").CallbackType, string: string, writerData: import("glitched-writer").WriterDataResponse) => void;
            call: (eventType: "finish" | "step") => void;
        };
        animator: {
            writer: any;
            last: number;
            rate: number;
            running: boolean;
            run: () => void;
            frame: (t: number) => any;
            animate: () => void;
        };
        queue?: {
            writer: any;
            isStopped: boolean;
            texts: string[];
            isLooping: boolean;
            loopInterval: number;
            interval: number;
            index: number;
            endCallback?: Callback | undefined;
            stop: () => void;
            resume: () => void;
        } | undefined;
        charTable: {
            index: number;
            l: string;
            gl: string;
            stepsLeft: number;
            ghosts: [string[], string[]];
            writer: any;
            stop: boolean;
            specialType: "tag" | "html_entity" | "whitespace" | undefined;
            afterGlitchChance: number;
            els?: {
                charEl?: HTMLSpanElement | undefined;
                ghostsBeforeEl: HTMLSpanElement;
                letterEl: HTMLSpanElement;
                ghostsAfterEl: HTMLSpanElement;
            } | undefined;
            readonly string: string;
            readonly finished: boolean;
            spanElement: HTMLSpanElement;
            type: () => Promise<boolean>;
            step: () => void;
        }[];
        goalText: string;
        lastText: string;
        string: string;
        updateString: () => void;
        readonly previousString: string;
        readonly writerData: {
            string: string;
            writer: any;
            options: {
                glyphs: string;
                charset: string[];
                space: string;
                oneAtATime: number | "word";
                maxGhosts: number;
                set: (options?: "default" | Partial<import("glitched-writer/lib/esm/types").AllCustomOptions> | "nier" | "typewriter" | "terminal" | "zalgo" | "neo" | "encrypted" | "bitbybit" | "cosmic" | null | undefined) => void;
                extend: (options?: "default" | Partial<import("glitched-writer/lib/esm/types").AllCustomOptions> | "nier" | "typewriter" | "terminal" | "zalgo" | "neo" | "encrypted" | "bitbybit" | "cosmic" | null | undefined) => void;
                parseOptions: (options?: "default" | Partial<import("glitched-writer/lib/esm/types").AllCustomOptions> | "nier" | "typewriter" | "terminal" | "zalgo" | "neo" | "encrypted" | "bitbybit" | "cosmic" | null | undefined) => Partial<import("glitched-writer/lib/esm/types").AllCustomOptions>;
                setCharset: () => void;
                setMaxGhosts: () => void;
                getGlyph: (char: import("glitched-writer/lib/esm/modules/char").default) => string;
                readonly steps: number;
                getInterval: (char: import("glitched-writer/lib/esm/modules/char").default) => number;
                getDelay: (char: import("glitched-writer/lib/esm/modules/char").default) => number;
                readonly mode: "matching" | "normal" | "erase" | "erase_smart" | "clear";
                readonly html: boolean;
                readonly endless: boolean;
                readonly fps: number;
                readonly letterize: boolean;
                readonly ghostChance: number;
                readonly changeChance: number;
                readonly glyphsFromText: boolean;
            };
            state: {
                writer: any;
                nGhosts: number;
                maxGhosts: number;
                progress: {
                    percent: number;
                    done: number;
                    todo: number;
                    increase: () => void;
                    reset: (todo: number) => void;
                    finish: () => void;
                };
                isTyping: boolean;
                isPaused: boolean;
                finished: boolean;
                erasing: boolean;
                readonly ghostsInLimit: boolean;
                play: () => void;
                pause: () => void;
                finish: () => void;
                addClass: (className?: "gw-writing" | "gw-erasing" | undefined) => void;
                removeClasses: () => void;
            };
            status?: "ERROR" | "SUCCESS" | undefined;
            message?: string | undefined;
            error?: any;
        };
        write: (text: string) => Promise<import("glitched-writer").WriterDataResponse>;
        queueWrite: (texts: string | string[] | HTMLElement | Element, queueInterval?: number | undefined, loop?: number | boolean | Callback | undefined) => void;
        add: (string: string) => Promise<import("glitched-writer").WriterDataResponse>;
        remove: (n: number) => Promise<import("glitched-writer").WriterDataResponse>;
        play: () => Promise<import("glitched-writer").WriterDataResponse>;
        pause: () => void;
        endless: (bool: boolean) => void;
        addCallback: (type: import("glitched-writer/lib/esm/types").CallbackType, callback: Callback) => GlitchedWriterClass;
        removeCallback: (type: import("glitched-writer/lib/esm/types").CallbackType, callback: Callback) => GlitchedWriterClass;
        manageWriting: (text: string | null) => Promise<import("glitched-writer").WriterDataResponse>;
        getWriterData: (status?: "ERROR" | "SUCCESS" | undefined, message?: string | undefined, error?: any) => import("glitched-writer").WriterDataResponse;
    }>;
    element: import("vue-demi").Ref<HTMLElement | null>;
    initialText: string;
}, unknown, {}, {}, import("vue-demi").ComponentOptionsMixin, import("vue-demi").ComponentOptionsMixin, Record<string, any>, string, import("vue-demi").VNodeProps & import("vue-demi").AllowedComponentProps & import("vue-demi").ComponentCustomProps, Readonly<{
    text?: unknown;
    pause?: unknown;
    preset?: unknown;
    options?: unknown;
    queue?: unknown;
    silent?: unknown;
    tag?: unknown;
} & {
    text: string | unknown[];
    pause: boolean;
    preset: string;
    options: Record<string, any>;
    queue: Record<string, any>;
    silent: boolean;
    tag: string;
} & {}>, {
    pause: boolean;
    preset: string;
    options: Record<string, any>;
    queue: Record<string, any>;
    silent: boolean;
    tag: string;
}>;
export default _default;
